Designing software is a complex and creative skill, which can only be
(effectively) performed by developers after many years of training. As such,
while it would seem a natural fit, there has been limited work, from a machine
learning perspective, on reducing the gap between acquiring this design ability
and the time it takes to fine tune it--experienced by many opportunistic
programmers. With this project, we will reduce this gap, by applying machine
learning to the problem of semi-automatically designing quality programs,
keeping humans in the loop and fostering program design inspiration when
innovation is required.

The use of machine learning techniques for program design is a promising
approach to learn and operationalize coding habits specific to star programmers
or to code bases. Machine learning techniques, such as structured prediction,
nonparametric bayesian analysis, and program induction, can leverage the
inherent structure of well-written (object-oriented) programs, and then capture,
in templates, their structural regularities. Templates are prewritten snippets
of code that developers frequently rely on when designing programs. They use
them to write common code constructs faster, to surround existing code with
enclosing blocks (e.g., \texttt{try/catch} clause), or to create new source
files. With templates, developers don't have to figure out what to write. It is
already before them, and they just have to fill it in.

While templates can help developers write common code faster, their rigidity
limits both customization and creativity to those anticipated by the template
creator \cite{Kumar2011-hy}. \pdm addresses this rigidity by exploiting both the
simplicity of templates and the diversity of available programs on the Web.
Given these ready available Web data, \pdm uses nonparametric bayesian analysis
\cite{allamanis2014mining} to capture structural regularities that occur often
in well-written programs, more often than expected by chance; structured
prediction \cite{collins2002discriminative} to learn how to transfer these
structural regularities between programs; and program induction
\cite{lake2015human} to learn how to fine tune (or evolve) those transferred
regularities.

Using machine learning techniques to exploits the structure of program
designs affords significant advantages over predesigned (cookie-cutter)
programs. Well-written (object-oriented) programs, for example, exhibit many
structural regularities, which were introduced to mold them with design and
coding principles intended to improve their quality. On version controlled
repositories, every compilable Java class is associated with an Abstract Syntax
Tree. This information can be used along with change history of this class to
reason about and to manipulate structure regularities, closer to what
experienced developers would do.

The proposed project will be implemented as part of the IntelliJ IDEA Community
Edition \cite{jet2017intellij}. IntelliJ IDEA is a Java integrated
development environment (IDE) for developing software. Developer-provided tools,
like this project, can be developed using IntelliJ IDEA Open API and then
installed on the IDE using IntelliJ Platform SDK. The platform will
automatically create a sandbox for copying and debugging the developed tool.

Like most machine learning based tools, this project requires lots of data and
data preprocessing. This includes data cleaning, munging and bringing data
to a suitable format, such that machine learning models can be applied on
that data. And a backend that indexes open source Java projects and uses
off-the-shelf decision procedures to verify code changes in the affected
programs.

This project focuses on implementing an infrastructure for applying machine
learning techniques to program design and then expose its functionality
through a RESTful API. The interface to the backend is modular and can easily
be extended to other machine learning techniques, such as Genetic Improvement
\cite{white2011evolutionary}.

%% We discuss related work and the preliminary results obtained during the
%% development of \jayhorn before discussing the proposed technical approach
%% and how this project will enable \pdm to verify a larger class of problems.
