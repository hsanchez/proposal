Designing software is a complex and creative skill, which can only be
(effectively) performed by developers after many years of training. As such,
while it would seem a natural fit, there has been limited work, from a machine
learning perspective, on reducing the gap between acquiring this design ability
and the time it takes to fine tune it, experienced by many citizen programmers.
With this project, we will reduce this gap, by applying machine learning to the
problem of semi-automatically designing quality programs, keeping humans in the
loop and fostering program design inspiration when innovation is required.

The use of machine learning techniques for program design is a promising
approach to learn and operationalize coding habits specific to star programmers
or to code bases. Machine learning techniques, such as structured prediction,
nonparametric bayesian analysis, and program induction, can leverage the
inherent structure of well-written (object-oriented) programs, and then capture,
in templates, their structural regularities. Templates are prewritten snippets
of code that developers frequently rely on when designing programs. They use
them to write common code constructs faster, to surround existing code with
enclosing blocks (e.g., \texttt{try/catch} clause), or to create new source
files. With templates, developers don't have to figure out what to write. It is
already before them, and they just have to fill it in.

While templates can help developers write common code faster, their rigidity
limits both customization and creativity to those anticipated by the template
creator \cite{Kumar2011-hy}. \pdm addresses this rigidity by exploiting both the
simplicity of templates and the diversity of available programs on the Web.
Given these ready available Web data, \pdm uses nonparametric bayesian analysis
\cite{allamanis2014mining} to capture structural regularities that occur often
in well-written programs, more often than expected by chance; structured
prediction \cite{collins2002discriminative} to learn how to transfer these
structural regularities between programs; and program induction
\cite{lake2015human} to learn how to fine tune (or evolve) those transfered
regularities.

Using machine learning techniques to exploits the structure of program
designs affords significant advantages over predesigned (cookie-cutter)
programs. Well-written (object-oriented) programs, for example, exhibit many
structural regularities, which were introduced to mold them with design and
coding principles intended to improve their quality. On version controlled
repositories, every compilable Java class is associated with an Abstract Syntax
Tree. This information can be used along with change history of this class to
reason about and to manipulate structure regularities, closer to what
experienced developers would do.

The proposed project will be implemented as part of the IntelliJ IDEA
Community Edition IDE \cite{jet2017intellij}. IntelliJ IDEA is a Java
integrated development environment (IDE) for developing software.
\todo(Finish this paragraph)

Like most modern integrated development environments, IntelliJ IDEA
architecture is modular. \todo(Finish this paragraph)

The proposed work focuses on the middle-end aspect of code generation.
\todo(Finish this paragraph)

% Automatically proving properties about programs that manipulate heap-based
% data structures is a hard problem. It requires inferring universally
% quantified properties about a potentially unbounded number of
% heap locations. State of the art verification techniques, such as Craig
% interpolation and property-based reachability, struggle finding such
% properties because of their limited support for quantifiers or their
% inability to generalize useful properties from individual examples.

% The use of \emph{heap invariants}~\cite{jayhorn16}
% is a simple but promising approach to infer such
% properties automatically.
% A heap invariant is a parameterized formula that summarizes all the
% states that objects of a certain type can take in a given program.

% Heap invariants can be inferred automatically using a Horn solver.
% The heap invariant for objects of a given type is represented
% by a predicate defined over arguments representing the reference
% variable and the fields of the given
% type. Using this predicate, heap access can now be abstracted in the
% spirit of assume-guarantee reasoning: reading a field from an
% object into a local variable is replaced by assuming the predicate
% (instantiated with the reference to the object and the local variables
% representing the field). Writing to a field of an object is replaced by
% asserting the predicate that represents the heap invariant of the
% object's type (instantiated with the updated fields and the reference
% to the object). Using this abstraction, the Horn solver can infer
% a heap invariant by finding an assignment for the associated
% predicate.
%
% Using heap invariants to encode interaction with heap-based data
% structures is light-weight, flexible, and
% easy to implement, and sufficient to verify useful safety properties
% such as non-nullness or overflows. The downside of this technique is that a na\"ive
% implementation is
% likely to be too imprecise to verify interesting programs. Two particular
% bottlenecks can be identified: 1) the more often a predicate is used, the
% more likely it becomes that the Horn solver produces an invariant that
% is a large disjunction which is too weak
%  to prove any interesting property. 2) The Horn solver has only access to the information passed as
% arguments to the predicate when searching for an invariant, which limits
% the class of invariants that can be inferred automatically to properties
% that hold for all objects of the same type. Properties, like sortedness,
% that state the relation between objects of the same type or properties
% that are different for objects depending on their allocation site
% cannot be inferred this way.
%
% This project proposes a new way of encoding Java bytecode into Horn clauses
% that alleviates the bottlenecks and assists a Horn solver
% in finding good heap invariants that are sufficient
% to verify realistic programs. To address the first bottleneck,
% this project combines the Horn clause
% representation of a program's control-flow with a Horn-based alias analysis
% to minimize the locations where a program interacts with the heap.
% The project will use this analysis to also infer a partial order over heap modifications that
% is used to identify more efficient disjunctive invariants. For the second
% bottleneck, this project will investigate ways to extend the predicates from
% which heap invariants are derived by adding additional arguments. These
% arguments can contain meta information, like the current calling context,
% or information about multiple objects to help the Horn solver infer
% more advanced properties like sortedness.
%
%
% The proposed research will be implemented as
%  part of the \jayhorn tool~\cite{jayhorn16}. \jayhorn is a model checker for Java
% bytecode that checks if no exception of a pre-defined set of types can leave the main
% method of a given program. User-provided assertions can be inserted on the source level
% using the Java assertion statement. The compiler automatically translates assertions into conditional
% exceptions.
%
%
% Like most modern verification tools, the architecture of \jayhorn includes three
% central steps. A front-end that parses the input language and applies a set of
% simplifying transformations; a middle-end that translates the simplified input
% program into an intermediate verification language while introducing necessary
% abstractions. And a backend that uses off-the-shelf decision procedures to verify
% properties about the program.
%
% The proposed work focuses on the middle-end aspect of verification. The project uses \jayhorn
% as the front-end that simplifies the given input program
% by making implicit semantics like exceptional flow and dynamic dispatch explicit (
% brieflyed discussed in the following section). The backend is provided
% by the off-the-shelf Horn solvers Eldarica~\cite{Rummer:2013:DIH:2526861.2526891}
% or Z3~\cite{demoura2008z3}. The interface to the backend is modular and can easily
% be extended to other solvers such as Spacer~\cite{Komuravelli:2014:SMC:2735050.2735053}.


%% We discuss related work and the preliminary results obtained during the
%% development of \jayhorn before discussing the proposed technical approach
%% and how this project will enable \pdm to verify a larger class of problems.
