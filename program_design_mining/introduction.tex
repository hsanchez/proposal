Automatically proving properties about programs that manipulate heap-based data structures 
is a hard problem. It requires inferring universally
quantified properties about a potentially unbounded number of 
heap locations. State of the art verification techniques, such as Craig 
interpolation and property-based reachability, struggle finding such
properties because of their limited support for quantifiers or their 
inability to generalize useful properties from individual examples. 

The use of \emph{heap invariants}~\cite{jayhorn16} 
is a simple but promising approach to infer such
properties automatically.
A heap invariant is a parameterized formula that summarizes all the
states that objects of a certain type can take in a given program.

Heap invariants can be inferred automatically using a Horn solver. 
The heap invariant for objects of a given type is represented 
by a predicate defined over arguments representing the reference 
variable and the fields of the given
type. Using this predicate, heap access can now be abstracted in the
spirit of assume-guarantee reasoning: reading a field from an
object into a local variable is replaced by assuming the predicate
(instantiated with the reference to the object and the local variables 
representing the field). Writing to a field of an object is replaced by 
asserting the predicate that represents the heap invariant of the
object's type (instantiated with the updated fields and the reference
to the object). Using this abstraction, the Horn solver can infer
a heap invariant by finding an assignment for the associated 
predicate. 

Using heap invariants to encode interaction with heap-based data 
structures is light-weight, flexible, and
easy to implement, and sufficient to verify useful safety properties
such as non-nullness or overflows. The downside of this technique is that a na\"ive 
implementation is
likely to be too imprecise to verify interesting programs. Two particular
bottlenecks can be identified: 1) the more often a predicate is used, the
more likely it becomes that the Horn solver produces an invariant that
is a large disjunction which is too weak 
 to prove any interesting property. 2) The Horn solver has only access to the information passed as
arguments to the predicate when searching for an invariant, which limits 
the class of invariants that can be inferred automatically to properties
that hold for all objects of the same type. Properties, like sortedness,
that state the relation between objects of the same type or properties
that are different for objects depending on their allocation site 
cannot be inferred this way.

This project proposes a new way of encoding Java bytecode into Horn clauses
that alleviates the bottlenecks and assists a Horn solver 
in finding good heap invariants that are sufficient
to verify realistic programs. To address the first bottleneck, 
this project combines the Horn clause 
representation of a program's control-flow with a Horn-based alias analysis 
to minimize the locations where a program interacts with the heap. 
The project will use this analysis to also infer a partial order over heap modifications that
is used to identify more efficient disjunctive invariants. For the second
bottleneck, this project will investigate ways to extend the predicates from
which heap invariants are derived by adding additional arguments. These
arguments can contain meta information, like the current calling context,
or information about multiple objects to help the Horn solver infer
more advanced properties like sortedness.


The proposed research will be implemented as
 part of the \jayhorn tool~\cite{jayhorn16}. \jayhorn is a model checker for Java 
bytecode that checks if no exception of a pre-defined set of types can leave the main 
method of a given program. User-provided assertions can be inserted on the source level
using the Java assertion statement. The compiler automatically translates assertions into conditional
exceptions.


Like most modern verification tools, the architecture of \jayhorn includes three 
central steps. A front-end that parses the input language and applies a set of 
simplifying transformations; a middle-end that translates the simplified input
program into an intermediate verification language while introducing necessary
abstractions. And a backend that uses off-the-shelf decision procedures to verify
properties about the program.

The proposed work focuses on the middle-end aspect of verification. The project uses \jayhorn
as the front-end that simplifies the given input program
by making implicit semantics like exceptional flow and dynamic dispatch explicit (
brieflyed discussed in the following section). The backend is provided 
by the off-the-shelf Horn solvers Eldarica~\cite{Rummer:2013:DIH:2526861.2526891} 
or Z3~\cite{demoura2008z3}. The interface to the backend is modular and can easily 
be extended to other solvers such as Spacer~\cite{Komuravelli:2014:SMC:2735050.2735053}.


% We discuss related work and the preliminary results obtained during the 
% development of \jayhorn before discussing the proposed technical approach 
% and how this project will enable \jayhorn to verify a larger class of problems.


